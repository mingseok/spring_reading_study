## 3장. 자바와 객체 지향

프로그래밍 발전사를 보면 개발자를 더욱 편하고 이롭게 하기 위한 과정이라고 한다.

<br/>

그렇지만, 절차적/구조적 프로그래밍까지의 과정은 인간이 기계를 

이해하려는 노력에서 크게 벗어나지 못했다. → 특히, `포인터`의 개념

<br/>

## “왜? 우리는 기계 종속적인 개발을 해야 하는가?”

“우리가 눈으로 보고”, “느끼고”, “생활하는 현실 세계처럼” 프로그래밍하는 방법은 없나?

하는 고민 속에서 `“객체 지향”`의 개념이 탄생했다.

```java
그 증거가 바로 "객체" 이다.
```

<br/><br/>

## 구조적 프로그래밍 언어

가장 중요한 것은 “함수”라고 한다. → `D&C` (=Divide and Conquer)

<br/>

아무리 복잡한 문제라도 작은 문제로 분할해서 하나씩 정복하다 보면

결국 해결된다는 전략이라고 말하고 있다.


<br/><br/>

## 객체 지향

```java
"주변에 사물을 인지하는 방식대로 프로그래밍할 수 있지 않을까?”
 하는 것이 객체 지향의 출발이라고 한다. -> 객체 지향은 직관적이다.
```

- 눈으로 보여지는 것

- 손으로 만져지는 것

머릿속으로 상상되는 모든 것은 사물이다

사물을 조금 더 멋진 용어로 객체, 영어로 Object라고 한다.


<br/><br/>

## 객체 지향을 이해하기 위한 큰 그림

- 세상에 존재하는 모든 것은 사물, 즉 객체이다.

- 각각의 사물을 고유하다.
- 사물은 속성을 갖는다.
- 사물은 행위를 한다.

<br/><br/>

## 사물을 분류(class)해서 이해하는 것이 인간의 인지법이다.

- 직립보행을 하며 말을 하는 존재를 사람이라고 분류한다.

- 연미복, 짧은 다리, 날지 못하는 새를 펭귄이라고 분류한다.
- 밤하늘에 반짝이는 사물들을 별이라고 분류한다.

```java
사람이라는 분류는
object : 김민석, 연아킴, 이세희
 속성  : 나이, 몸무게, 키
 행위  : 먹다, 자다, 울다, 방귀 뀌다, 싸다
```

<br/><br/>

## 객체 지향의 4대 특성

- 캡슐화 : 정보 은닉

- 상속 : 재사용
- 추상화 : 모델링
- 다형성 : 사용 편의

<br/><br/>


## 클래스 vs 객체 == 붕어빵틀 vs 붕어빵

클래스와 객체의 관계가 붕어빵틀과 붕어빵이 아니라고 필자는 설명하고 있다.

- `“나 또한, 지금까지 이렇게 생각했기에, 무슨말인가 싶었다”`

```java
붕어빵틀 붕어빵 = new 붕어빵틀(); // 이게 맞아?
```

<br/>

붕어빵틀을 생산하는 금형기계가 있다면,

금형 기계는 붕어빵틀을 찍어내는 클래스가 된다

```java
금형기계 붕어빵틀 = new 금형기계(); // 맞아..?
```

<br/>

새로운 금형기계를 하나 만들었더니 붕어빵틀이 되었다? -> 말이 안되는 설명이다.

빨리 붕어빵틀과 붕어빵 개념을 버리자.

<br/><br/>

## 질문)

```java
- 사람은 클래스인가? 객체인가?

- 김연아는 클래스인가? 객체인가?

- 뽀로로는 클래스인가? 객체인가?

- 펭귄은 클래스인가? 객체인가?
```

사람과 펭귄은 클래스다.

김연아와 뽀로로는 객체다 (=검색해보면 나온다)

<br/><br/>

## 클래스와 객체를 구분하는 방법

```java
- 사람의 나이는 몇 살인가?

- 김연아의 나이는 몇 살인가?

- 뽀로로의 나이는 몇 살인가?

- 펭귄의 나이는 몇 살인가?
```

클래스는 분류에 대한 개념이지 실체가 아니다. → 실체는 객체이다.

<br/>

### 기억하기.

```java
클래스 : 객체 = 펭귄 : 뽀로로 = 사람 : 김연아
```

<br/><br/>

## 추상화: 모델링

추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 

재조합하는 것이라고 정리 할 수 있다.

<br/>

객체 지향에서 말하는 객체와 클래스에 대해 필자의 설명

```java
객체: 세상에 존재하는 유일무이한 사물
클래스: 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념

클래스 : 객체 = 펭귄 : 뽀로로 = 사람 : 김연아
```

세상에 존재하는 유일무이한 객체를 특성(속성 + 기능)에 따라 분류하면, 

객체를 통칭할 수 있는 집합적 개념, 즉 클래스(분류)가 나오게 된다

- 객체는 유일무이한 사물이다.

- 클래스는 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념이다.
    - 클래스는 → 분류이다
        - 즉, 객체들을 특성에 따라 분류한다는 의미

<br/><br/>

## 새로운 사람이 태어났다고 해보자.

객체 지향 언어인 자바로 표현하면? → 이름은 홍길동

```java
사람 홍길동 = new 사람();
```

<br/>

### 또, 새로운 사람이 태어났다면?

```java
사람 줄리엣 = new 사람();
```

사람이라는 클래스(분류)를 이용해 새로운 하나의 사람(객체)을 

만들어 홍길동이라는 이름을 지어준 것이다.

<br/><br/>

## 그래서, 추상화랑 무슨 관련이 있는거야?

사람이라는 클래스를 설계한다고 생각해보자.

<br/>

사람 클래스를 만들기 위해 주변에서 보이는 실체들, 

즉 사람 객체들을 관찰해서 사람 객체들이 가진 공통된 특성을 찾게 된다.

<br/>

### 속성

```java
시력, 몸무게, 혈액형, 키, 나이, 직업, 취미 등등
```



### 기능 / 행위

```java
먹다, 자다, 일하다, 운전하다, 울다 등등 -> 동사로 표현되는 특성을 메서드
```

<br/><br/>

## 애플리케이션의 경계

```java
"내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?"
```

- 병원 애플리케이션

    - 환자를 의미하는 좀 더 구체적인 이름
- 은행 애플리케이션

    - 고객이라는 구체적인 이름

두개의 클래스 설계도 역시 달라져야 한다.

<br/>

### 병원 애플리케이션

- 사람이란? → 환자다

    - 필드 : 시력, 몸무게, 혈액형, 키, 나이

    - 메서드 : 먹다(), 자다(), 운동하다()

<br/>

### 은행 애플리케이션

- 사람이란? → 고객이다.

    - 필드 : 나이, 직업, 연봉

    - 메서드 : 일하다(), 입금하다(), 출금하다(), 대출하다()

<br/>

모델은 실제 사물을 정확히 복제하는 게 아니라, 

목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. 

```java
지구본이 지구를 모델링하고 있다.
과학 박물관에는 태양계를 모델링하고 있다.
```

<br/><br/>

## 기억하기!

자바는 객체 지향의 추상화를 어떻게 지원하고 있을까?

바로 `class` 키워드를 통해 지원하고 있는 것이다.

<br/><br/>

## 클래스 설계

즉, 모델링에서 제일 중요한 것은 추상화이다.

추상화를 통해 애플리케이션 경계 내에서 관심 있는 특성만 뽑는 것이다.

- 추상화의 결과물은 모델이다.

    - 모델은 자바 언어에서 클래스로 표현된다.

```java
쥐 클래스
- 이름, 나이, 꼬리수
- 울다()
```

<br/>

### 코드

```java
public class Mouse {
  public String name;
  public int age;
  public int countOfTail;

  public void sing() {
    System.out.println("찍찍");
  }
}
```

<br/><br/>

## 정적(static) 멤버

정적 속성은 해당 클래스의 모든 객체가 같은 값을 가질 때 사용하는 것이 기본이다.

- 사람 클래스의 인구

- 고양이 클래스의 다리 개수
- 승용차 클래스의 바퀴 개수
- 보병 클래스의 주특기번호
- 남자 클래스의 주민등록번호 성별코드
- 박카스 클래스의 재조사명, 용량, 성분

<br/><br/>

## 상속: 재사용 + 확장

객체 지향에서 상속이란 일반인들이 생각하는 상속이 아닌 

확장, 세분화, 상위 클래스 - 하위 클래스 개념으로 이해하자.

<br/>

사람들은 클래스의 특성을 상속한다는 말에서 특성을 빼고 

클래스를 상속한다는 뜻으로 오해하니 부모-자식 관계가 나와 버린 것

```java
제대로 된 표현은 "상위 클래스 - 하위 클래스"
```

<br/>

![이미지](/3장/김민석/참고2.PNG)

이미지 참조 : https://yongdev.tistory.com/132

<br/><br/>

## 상속 관계에서 반드시 만족해야 되는 문장

```java
하위 클래스는 상위 클래스다.
```

- 아버지는 할아버지다?
- 아들은 아버지다?

- 딸은 아버지다?

이상하고 괴이하다.

<br/>

### 자연스럽게 작성해보자면,

- 포유류는 동물이다

- 고래는 포유류이다
- 고래는 동물이다.

`“하위 클래스는 상위 클래스이다”` 라는 문장은 
LSP(리스코프 치환 원칙)을 나타내는 말이다.

<br/>

### 코드로 예시

```java
아버지 영희아빠 = new 딸();
// 딸을 낳으니 아버지 역할을 하는 영희아빠라 이름 지었다? -> 이상하다.

동물 뽀로로 = new 펭귄();
// 펭귄을 낳으니 동물 역할을 하는 뽀로로라 이름 지었다. -> 말은 된다.
```

<br/><br/>

## 클래스명은 클래스명 답게!

```java
조류 bird = new 조류(); // 이렇게 작명하면 안된다.
```

문제는, bird라는 단어 자체가 객체보다는 클래스, 즉 분류에 가깝기 때문이다.

<br/>

객체와 클래스 구분법을 생각해보자.

- 조류의 나이는? → 답할 수 있겠는가? → 못하기에 클래스.

- bird의 나이는? → 답할 수 있겠는가? → 못하기에 클래스.

<br/><br/>

## 인터페이스 설명

- 인터페이스 : 구현 클래스 `“be able to"` 인터페이스

    - `“be able to"` : “무엇을 할 수 있는” 이라는 표현 형태로 만드는 것이 좋다

        - Comparable 인터페이스 : 비교할 수 있는

        - Runnable 인터페이스 : 실행할 수 있는
- 해석 : 구현 클래스는 인터페이스할 수 있다.

- 예제 : 고래는 헤엄칠 수 있다.

<br/>

![이미지](/3장/김민석/참고3.PNG)

이미지 참조 : https://blog.naver.com/rain483/220514873242

<br/>

상위 클래스는 하위 클래스에게 특성(속성과 메서드)을 상속해 주고,

인터페이스는 클래스가 “무엇을 할 수 있다”라고 하는 기능을 구현하도록 강제한다.

<br/><br/>

## 궁금증

- 상위 클래스는 하위 클래스에게 물려줄 특성이 많을수록 좋을까?

- 인터페이스는 구현을 강제할 메서드가 많을수록 좋을까?

```java
상위 클래스는 물려줄 특성이 풍성할수록 좋고,
인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다.
```


<br/>

상위 클래스가 풍성할수록 좋은 이유는 LSP(리스코프 치환 원칙)에 따른 이유라고 할 수 있고,

인터페이스에 메서드가 적을수록 좋은 이유는, ISP(인터페이스 분할 원칙)에 따른 이유이다.

<br/><br/>

## 이해하기 쉬운 코드란?

```java
// 펭귄 한 마리가 태어나니 펭귄 역할을 하는 pororo라 이름 지었다.
Penguin pororo = new Penguin();

// pororo의 name을 "뽀로로"라 하자.
pororo.name = "뽀로로";

// pororo의 habitat(서식지)를 "남극"이라 하자.
pororo.habitat = "남극";

// pororo야 너의 이름을 보여다오.
pororo.showName();

// pororo야 너의 서식지를 보여다오.
pororo.showHabitat();
```

<br/><br/>

## 다형성

다형성은 개발자가 프로그램을 작성할 때 사용편의성을 준다.

```java
Animal pingu = new Penguin();
```

<br/>

오버로딩 : 같은 메서드 이름, 다른 인자 리스트

오버라이딩 : 상위 클래스의 메서드와 같은 메서드 이름, 같은 인자 리스트

```java
상위 클래스 타입의 객체 참조 변수를 사용하더라도 
하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다.
```

<br/>

### Animal

```java
public class Animal {
	public String name;

	public void showName() {
		System.out.printf("안녕 나는 %s야. 반가워\n", name);
	}
}
```

<br/>

### Penguin

```java
public class Penguin extends Animal {
	public String habitat;	

	public void showHabitat() {
		System.out.printf("%s는 %s에 살아\n", name, habitat);
	}

	//오버라이딩 - 재정의: 상위클래스의 메서드와 같은 메서드 이름, 같은 인자 리스트
	public void showName() {
		System.out.println("어머 내 이름은 알아서 뭐하게요?");
	}

	// 오버로딩 - 중복정의: 같은 메서드 이름, 다른 인자 리스트
	public void showName(String yourName) {
		System.out.printf("%s 안녕, 나는 %s라고 해\n", yourName, name);
	}
}
```

<br/>

### Driver

```java
public class Driver {
	public static void main(String[] args) {
		Penguin pororo = new Penguin();

		pororo.name = "뽀로로";
		pororo.habitat = "남극";

		pororo.showName();
		pororo.showName("초보람보");
		pororo.showHabitat();

		Animal pingu = new Penguin();

		pingu.name = "핑구";
		pingu.showName();
	}
}

-- 출력 --
어머 내 이름 알아서 뭐하게요?
초보람보 안녕, 나는 뽀로로라고 해
뽀로로는 남극에 살아
어머 내 이름은 알아서 뭐하게요?
```

<br/><br/>

## 캡슐화: 정보 은닉

정보은닉하면 생각나는 접근제어자

- `private`

- `pretected`
- `public`
- `default`

상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 참조 변수를 통해 접근할 것

정적 멤버는 클래스명.정적멤버 형식으로만 접근하는 것을 권장.